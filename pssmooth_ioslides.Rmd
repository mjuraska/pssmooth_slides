---
title: "R package pssmooth"
author: "Michal Juraska"
date: "September 24-26, 2018"
output: 
  ioslides_presentation: 
    widescreen: true
    transition: 0
---

```{r, include=FALSE, cache=TRUE}
# the next 4 lines will be replaced by library(pssmooth) once an updated package is installed
library(np)
library(osDesign)
library(chngpt)
source("t:/vaccine/sanofipasteur/dengue/manuscript_VEcurveMethod/pssmooth/code/pssmooth.R")

dataDir <- "t:/vaccine/sanofipasteur/dengue/CYD14and15/Mon13CoR/data"
# 'outDir1' stores bootstrap estimates in the manuscript
# I use these because parallelization would be needed for bootstrap in the slide examples
outDir1 <- "t:/vaccine/sanofipasteur/dengue/manuscript_VEcurveMethod/Routput"
# 'outDir2' stores point estimates in the slide examples
outDir2 <- "t:/vaccine/sanofipasteur/dengue/manuscript_VEcurveMethod/pssmooth/Routput"

data <- read.csv(file.path(dataDir,"cyd14and15m13CoRdata.csv"), header=TRUE)
data <- subset(data, AGEYRS>=9)
data <- subset(data, select=c(VACC, AGE, COUNTRY, bAUC, IMPSTLOG.AUCMB, ofstatus_m13, wts))
colnames(data) <- c("vax", "age", "country", "bTiter", "m13Titer", "VCDpostM13", "wts")

# the below .RData files were generated by CYD14and15_MCEPcurve_pssmooth.R because it takes
# too long to obtain these files
load(file.path(outDir2, "out1_riskCurve.RData"))
out1.riskCurve <- oList

load(file.path(outDir2, "out2_riskCurve.RData"))
out2.riskCurve <- oList

load(file.path(outDir2, "out3_riskCurve.RData"))
out3.riskCurve <- oList

load(file.path(outDir2, "out5_riskCurve.RData"))
out5.riskCurve <- oList
```


## Data: 9-16 year-olds at risk for VCD at month 13 in CYD14+CYD15
```{r}
head(data)
```

## Data: 9-16 year-olds at risk for VCD at month 13 in CYD14+CYD15
```{r}
head(subset(data, !is.na(bTiter)))
```

## R package pssmooth: inference about \(\small\, \mathop{\mathrm{mCEP}}(s_1)\) curves
1. `riskCurve:` calculates point estimates of $P(Y(z)=1 | S(1)=s_1)$, $z=0,1$
2. `bootRiskCurve:` calculates bootstrap estimates of $P(Y(z)=1 | S(1)=s_1)$, $z=0,1$
3. `summary:` tabulates point and interval estimates of $\mathop{\mathrm{mCEP}}(s_1)$
4. `plotMCEPcurve:` plots point and interval estimates of $\mathop{\mathrm{mCEP}}(s_1)$
5. `testConstancy:` tests $H_0^1$ or $H_0^2$
6. `testEquality:` tests $H_0^3$ or $H_0^4$
7. Parallel computing

## 1. Point estimation of \(\small\, P(Y(z)=1 \mid S(1)=s_1)\)
```{r, eval=FALSE}
psRange <- range(data$m13Titer, na.rm = TRUE)
psGrid <- seq(psRange[1], psRange[2], length.out = 100)

library(pssmooth)
out1.riskCurve <- 
  riskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
            bsm = "bTiter", 
            tx = "vax", 
            data = data, 
            psGrid = psGrid)
```

## 1. Point estimation of \(\small\, P(Y(z)=1 \mid S(1)=s_1)\) {.smaller}
```{r}
names(out1.riskCurve)
out1.riskCurve$psGrid[seq(1, 100, by = 25)]
out1.riskCurve$plaRiskCurve[seq(1, 100, by = 25)]
out1.riskCurve$txRiskCurve[seq(1, 100, by = 25)]
```

## 1. Point estimation of \(\small\, P(Y(z)=1 \mid S(1)=s_1)\) {.smaller}
```{r, eval=FALSE}
out2.riskCurve <- 
  riskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
            bsm = "bTiter", 
            tx = "vax", 
            data = data,
            bwtype = "generalized_nn"
            psGrid = psGrid)

out3.riskCurve <- 
  riskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
            bsm = "bTiter", 
            tx = "vax", 
            data = data,
            hinge = TRUE,
            psGrid = psGrid)

out4.riskCurve <- 
  riskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
            bsm = "bTiter", 
            tx = "vax", 
            data = data, 
            hinge = TRUE,
            weights = "wts",
            psGrid = psGrid)
```

## 1. Point estimation of \(\small\, P(Y(z)=1 \mid S(1)=s_1)\) {.smaller}
```{r}
data$bTiterC <- cut(data$bTiter, breaks = c(-Inf, log10(5), 1:5), labels=FALSE)
table(data$bTiterC)
```
```{r, results='hide'}
data$m13TiterC <- cut(data$m13Titer, breaks = c(-Inf, log10(5), 1:5), labels=FALSE)
table(data$m13TiterC)
```

```{r, eval=FALSE}
out5.riskCurve <- 
  riskCurve(formula = VCDpostM13 ~ m13TiterC + factor(age) + factor(country), 
            bsm = "bTiterC", 
            tx = "vax", 
            data = data,
            pstype = "ordered",
            bsmtype = "ordered",
            hinge = TRUE,
            psGrid = sort(unique(data$m13TiterC)))
```

## 1. Point estimation of \(\small\, P(Y(z)=1 \mid S(1)=s_1)\)
```{r, echo=FALSE, fig.width=9, fig.height=6, fig.align='center', out.width='80%'}
par(mfrow=c(2,2))
plotMCEPcurve(summary(out1.riskCurve, contrast="te"), title="Fixed Optimal Bandwidths", xLab="Average Log10 M13 Titer in Vaccinees", yLab="Vaccine Efficacy", yLim=c(-0.7,1))
plotMCEPcurve(summary(out2.riskCurve, contrast="te"), title="Variable Optimal Bandwidths", xLab="Average Log10 M13 Titer in Vaccinees", yLab="Vaccine Efficacy", yLim=c(-0.7,1))
plotMCEPcurve(summary(out3.riskCurve, contrast="te"), title="Hinge Model", xLab="Average Log10 M13 Titer in Vaccinees", yLab="Vaccine Efficacy", yLim=c(-0.7,1))
# out3.riskCurve and out4.riskCurve are identical because the column "wts" in the data was calculated the same way riskCurve calculates weights
plotMCEPcurve(summary(out5.riskCurve, contrast="te"), title="Ordered Categorical Biomarker", xLab="Avg Log10 M13 Titer Category in Vaccinees", yLab="Vaccine Efficacy", yLim=c(-0.7,1), pType="p")
```

## 2. Bootstrap estimation of \(\scriptsize\, P(Y(z)=1 \mid S(1)=s_1)\) {.smaller}
```{r, eval=FALSE}
out4.riskCurve <- 
  riskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
            bsm = "bTiter", 
            tx = "vax", 
            data = data, 
            hinge = TRUE,
            weights = "wts",
            psGrid = psGrid)

out4.bootRiskCurve <-
  bootRiskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
                bsm = "bTiter", 
                tx = "vax", 
                data = data,
                hinge = TRUE,
                weights = "wts",
                psGrid = psGrid,
                iter = 500,
                seed = 9)
```

## 2. Bootstrap estimation of \(\scriptsize\, P(Y(z)=1 \mid S(1)=s_1)\) {.smaller}
```{r, include=FALSE, cache=TRUE}
# the below .RData file was generated by CYD14and15_MCEPcurve.R, and
# these results are shown in the manuscript
load(file.path(outDir1, "riskCurves_CYD14and15_9to16_AUCMB_hingePoint.RData"))
out4.riskCurve <- oList
out4.riskCurve$psGrid <- out4.riskCurve$markerVals
out4.riskCurve$cpointT <- out4.riskCurve$cpointV
class(out4.riskCurve) <- "riskCurve"

# the below .RData file was generated by the parallelized version of CYD14and15_bootRiskCurves.R, and
# these results are shown in the manuscript
load(file.path(outDir1, "bRiskCurves_CYD14and15_9to16_AUCMB_hingePoint_RERUN.RData"))
out4.bootRiskCurve <- as.list(NULL)
out4.bootRiskCurve$psGrid <- result[[1]]$markerVals
out4.bootRiskCurve$plaRiskCurveBoot <- sapply(result, "[[", "plaRiskCurveBootEst")
out4.bootRiskCurve$txRiskCurveBoot <- sapply(result, "[[", "txRiskCurveBootEst")
out4.bootRiskCurve$cpointTboot <- out4.bootRiskCurve$cpointPboot <- NA
```

```{r}
names(out4.bootRiskCurve)
out4.bootRiskCurve$psGrid[c(1, 25, 50, 73)]
out4.bootRiskCurve$plaRiskCurveBoot[c(1, 25, 50, 73), 1:5]
```

## 3. Summary of estimation of \(\small\, \mathop{\mathrm{mCEP}}(s_1)\)
```{r}
summary(out4.riskCurve, out4.bootRiskCurve, contrast = "te")[c(1, 25, 50, 73),]
summary(out4.riskCurve, out4.bootRiskCurve, contrast = "rd")[c(1, 25, 50, 73),]
```

## 4. Plotting of estimates of \(\small\, \mathop{\mathrm{mCEP}}(s_1)\) {.smaller}
```{r, fig.width=5.8, fig.height=5.8, fig.align='center', out.width='40%'}
plotMCEPcurve(summary(out4.riskCurve, out4.bootRiskCurve, contrast = "te"), 
              hingePoint = with(out4.riskCurve, round(min(cpointP, cpointT), 1)), 
              xLab = "Average Log10 M13 Titer in Vaccinees", 
              yLab = "Vaccine Efficacy")
```

## 4. Plotting of estimates of \(\small\, \mathop{\mathrm{mCEP}}(s_1)\) {.smaller}
```{r, fig.width=5.8, fig.height=5.8, fig.align='center', out.width='40%'}
plotMCEPcurve(summary(out4.riskCurve, out4.bootRiskCurve, contrast = "logrr"), 
              hingePoint = with(out4.riskCurve, round(min(cpointP, cpointT), 1)), 
              xLab = "Average Log10 M13 Titer in Vaccinees", 
              yLab = "Log Relative Risk")
```

## 4. Plotting of estimates of \(\small\, \mathop{\mathrm{mCEP}}(s_1)\) {.smaller}
```{r, fig.width=5.8, fig.height=5.8, fig.align='center', out.width='40%'}
plotMCEPcurve(summary(out4.riskCurve, out4.bootRiskCurve, contrast = "rd"), 
              hingePoint = with(out4.riskCurve, round(min(cpointP, cpointT), 1)), 
              xLab = "Average Log10 M13 Titer in Vaccinees", 
              yLab = "Risk Difference (Placebo - Vaccine)")
```

## 5. Test of \(\small\, \{H^1_0: \mathop{\mathrm{mCEP}}(s_1) \equiv CE\) for all \(\small\, s_1 \in \mathbb{S}\}\)
First, we need to obtain $\widehat{CE}$:
```{r}
fit <- glm(VCDpostM13 ~ vax, data = data, family = binomial)
overallRisk <- predict(fit, newdata = data.frame(vax = 0:1), type = "response")
overallRisk
```

## 5. Test of \(\small\, \{H^1_0: \mathop{\mathrm{mCEP}}(s_1) \equiv CE\) for all \(\small\, s_1 \in \mathbb{S}\}\) {.smaller}
```{r}
testConstancy(object = out4.riskCurve, 
              boot = out4.bootRiskCurve,
              contrast = "te",
              null = "H01",
              overallPlaRisk = overallRisk[1],
              overallTxRisk = overallRisk[2])

testConstancy(object = out4.riskCurve, 
              boot = out4.bootRiskCurve,
              contrast = "rd",
              null = "H01",
              overallPlaRisk = overallRisk[1],
              overallTxRisk = overallRisk[2])
```

## 5. Test of \(\small\, \{H^2_0: \mathop{\mathrm{mCEP}}(s_1) \equiv c\) for all \(\small\, s_1 \in \mathbb{S}_1 \subseteq \mathbb{S}\) and a known constant \(\small\, c \in \mathbb{R}\}\) {.smaller}
```{r}
testConstancy(object = out4.riskCurve, 
              boot = out4.bootRiskCurve,
              contrast = "te",
              null = "H02",
              MCEPconstantH02 = 0,
              limS1 = c(0.6, with(out4.riskCurve, min(cpointP, cpointT))))

testConstancy(object = out4.riskCurve, 
              boot = out4.bootRiskCurve,
              contrast = "te",
              null = "H02",
              MCEPconstantH02 = 0.3,
              limS1 = c(0.6, with(out4.riskCurve, min(cpointP, cpointT))))
```

## 5. Test of \(\small\, \{H^2_0: \mathop{\mathrm{mCEP}}(s_1) \equiv c\) for all \(\small\, s_1 \in \mathbb{S}_1 \subseteq \mathbb{S}\) and a known constant \(\small\, c \in \mathbb{R}\}\) {.smaller}
```{r}
testConstancy(object = out4.riskCurve, 
              boot = out4.bootRiskCurve,
              contrast = "rd",
              null = "H02",
              MCEPconstantH02 = 0,
              limS1 = c(0.6, with(out4.riskCurve, min(cpointP, cpointT))))

testConstancy(object = out4.riskCurve, 
              boot = out4.bootRiskCurve,
              contrast = "rd",
              null = "H02",
              MCEPconstantH02 = 0.02,
              limS1 = c(0.6, with(out4.riskCurve, min(cpointP, cpointT))))
```

## 6. Test of \(\small\, \{H^3_0: \mathop{\mathrm{mCEP}}_1(s_1) = \mathop{\mathrm{mCEP}}_2(s_1)\) for all \(\small\, s_1 \in \mathbb{S}_1 \subseteq \mathbb{S}\}\), where \(\small\, \mathop{\mathrm{mCEP}}_1\) and \(\small\, \mathop{\mathrm{mCEP}}_2\) are each associated with either a different biomarker or a different endpoint or both {.smaller}
```{r, eval=FALSE}
testEquality(object1 = denv3.riskCurve,
             object2 = denv4.riskCurve,
             boot1 = denv3.bootRiskCurve,
             boot2 = denv4.bootRiskCurve,
             contrast = "te",
             null = "H03")

testEquality(object1 = denv3.riskCurve,
             object2 = denv4.riskCurve,
             boot1 = denv3.bootRiskCurve,
             boot2 = denv4.bootRiskCurve,
             contrast = "rd",
             null = "H03")
```

## 6. Test of \(\small\, \{H^4_0: \mathop{\mathrm{mCEP}}(s_1\mid X=1) = \mathop{\mathrm{mCEP}}(s_1 \mid X=0)\) for all \(\small\, s_1 \in \mathbb{S}_1 \subseteq \mathbb{S}\}\), where \(\small\, X\) is a baseline dichotomous phase 1 covariate of interest {.smaller}
```{r, eval=FALSE}
testEquality(object1 = cyd14.riskCurve,
             object2 = cyd15.riskCurve,
             boot1 = cyd14.bootRiskCurve,
             boot2 = cyd15.bootRiskCurve,
             contrast = "te",
             null = "H04")

testEquality(object1 = cyd14.riskCurve,
             object2 = cyd15.riskCurve,
             boot1 = cyd14.bootRiskCurve,
             boot2 = cyd15.bootRiskCurve,
             contrast = "rd",
             null = "H04")
```

## 7. Parallel computing
Problem:
```{r, eval=FALSE}
out4.bootRiskCurve <-
  bootRiskCurve(formula = VCDpostM13 ~ m13Titer + factor(age) + factor(country), 
                bsm = "bTiter", 
                tx = "vax", 
                data = data,
                hinge = TRUE,
                weights = "wts",
                psGrid = psGrid,
                iter = 500,
                seed = 9)
```
would take too long (i.e., months) to run

## 7. Parallel computing {.smaller}
- Many parallel iterations using the R package `rslurm`
- `slurm_apply` creates a folder of R files for independent and parallel execution on a cluster:
```{r, eval=FALSE}
slurm_apply(bootRiskCurve,        # a function that executes a single iteration
            pars,                 # a data frame with input arguments for bootRiskCurve
            jobname = "bootOut",  # an output directory name
            nodes = 500)          # number of bootstrap iterations
```
- Results from each completed iteration (with a different unique `seed`) written in a **separate** RDS file:
    - A failed iteration (e.g., due to a cluster or code error) does not interrupt other iterations in progress
    - Partial results available for examination
    - Partial results allow to project the time to completion
- `get_slurm_out` combines all RDS files into a single data frame

##    
<br><br><br><br>
<div class="centered">
Package website on CRAN:

https://cran.r-project.org/package=pssmooth
<br><br>

Code development:

https://github.com/mjuraska/pssmooth
</div>